// Resonant drums base a sample and filtered karplus - pin PD0 audio PWM output //

#include <HardwareTimer.h>

HardwareTimer Timer(TIM2);

#define SAMPLE_RATE 44100
#define DRUM        768
#define SIZE        DRUM/2
#define OFFSET      16
#define BPM         120

  int out = 0;
  int last = 0;
  int curr = 0;
  uint8_t delaymem[SIZE];
  uint16_t locat = 0;
  uint16_t cnt = 0;
  int accum = 0;
  int lowpass = 0;
  bool trig = false;

const uint8_t drum[] = {

  128,129,129,129,129,130,130,131,132,132,137,132,126,100,140,249,79,164,144,144,113,142,125,114,123,73,116,66,83,55,79,59,67,60,70,63,72,66,86,94,101,116,107,136,182,141,158,223,186,199,207,227,237,239,239,240,235,223,198,196,188,183,171,168,156,150,141,132,124,120,105,100,89,75,71,70,56,46,44,33,29,29,28,25,22,23,22,23,25,28,32,39,48,51,57,66,
  71,79,87,97,105,112,119,128,134,141,151,156,168,168,188,181,201,196,227,221,238,235,234,238,238,235,234,229,224,212,207,193,188,184,177,170,165,158,151,142,137,128,121,113,108,102,95,88,84,77,75,67,65,57,56,49,49,44,43,42,34,36,32,35,37,36,33,40,38,43,42,48,48,52,54,55,63,69,70,74,80,84,89,92,98,104,107,111,115,119,120,129,123,134,137,140,144,144,147,150,
  154,152,155,158,157,162,158,159,162,161,160,160,162,162,161,162,163,164,163,168,167,169,169,173,171,174,171,176,176,177,175,179,176,175,174,173,172,172,166,166,162,158,156,152,148,143,140,134,131,125,121,117,113,108,104,100,95,91,87,82,80,74,72,67,64,60,55,54,51,49,46,42,44,43,43,41,42,43,45,46,48,49,51,55,58,61,66,72,76,81,86,92,100,104,112,116,123,128,135,140,
  145,150,155,160,163,168,171,176,178,180,182,185,187,188,189,190,188,190,189,188,186,188,183,184,180,179,175,174,169,168,165,160,158,155,151,148,145,142,138,135,132,129,126,124,121,118,116,114,112,110,109,106,106,104,104,103,103,102,102,102,102,103,103,104,105,105,106,106,108,109,111,112,113,114,115,116,118,119,121,121,123,124,125,126,127,128,129,130,131,132,132,133,133,134,134,134,135,134,134,134,
  134,134,133,133,133,132,132,132,131,131,130,130,130,129,129,128,128,128,128,128,127,127,127,127,127,127,127,127,127,127,127,128,128,128,128,129,129,130,130,130,131,131,132,132,133,133,134,134,135,135,135,136,136,136,136,136,136,136,136,136,136,136,136,136,136,135,135,135,135,134,134,134,134,134,134,133,133,133,133,133,133,133,133,133,133,133,132,132,132,132,132,132,132,132,131,131,131,131,131,131,
  130,130,130,130,130,130,129,129,129,129,129,129,129,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,129,129,129,129,129,129,130,130,130,130,131,131,131,131,131,132,132,132,132,132,132,133,133,133,133,133,133,133,133,133,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,134,133,133,133,133,133,133,133,133,133,132,132,132,132,
  132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,
  131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,132,132,132,132,132,132,132,132,132,132,132,132,132,132,132,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,131,130,130,130,130,130,130,130,130,130,131,131,131,131,131,130,130,130,130,130,130,130,130,130,130,130,130,130,130,129,
  129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,128,128,128,128,128,128,128,128,128,128,128,128,128

};

void timerHandler(void) {

	Timer.pause();

  if(trig) {

    for (int i = 0; i < SIZE; i++) delaymem[i] = drum[i];
    trig = false;
    cnt = 0;

  } else {

	  delaymem[locat++] = -out;
    if (locat >= SIZE) locat = 0;
    if (cnt >= DRUM) cnt = DRUM;
    curr = delaymem[locat];
    out = accum >> lowpass;
    accum = accum - out + ((last>>1) + (curr>>1));
    last = curr;

	  TIM1->CH1CVR = (out + drum[cnt++]) >> 1;

  }
  
  Timer.resume();

}

void PWM_init() {

	RCC->APB2PCENR |= RCC_APB2Periph_GPIOD | RCC_APB2Periph_TIM1;
	GPIOD->CFGLR &= ~(0xf<<(4*0));
	GPIOD->CFGLR |= (GPIO_Speed_10MHz | GPIO_Mode_AF_PP)<<(4*0);
	RCC->APB2PRSTR |= RCC_APB2Periph_TIM1;
	RCC->APB2PRSTR &= ~RCC_APB2Periph_TIM1;
	TIM1->PSC = 0x0000;
	TIM1->ATRLR = 255;
	TIM1->SWEVGR |= TIM_UG;
	TIM1->CCER |= TIM_CC1NE | TIM_CC1NP;
	TIM1->CCER |= TIM_CC4E | TIM_CC4P;
	TIM1->CHCTLR1 |= TIM_OC1M_2 | TIM_OC1M_1;
	TIM1->CH1CVR = 128;
	TIM1->BDTR |= TIM_MOE;
	TIM1->CTLR1 |= TIM_CEN;

}

void setup() {

	PWM_init();
	
	Timer.setOverflow(SAMPLE_RATE, HERTZ_FORMAT);
  Timer.attachInterrupt(timerHandler);
  Timer.resume();

}

void loop() {

  int rate = random(8000, 48000);
  Timer.setOverflow(rate, HERTZ_FORMAT);

  trig = true;
  lowpass = random(0, 6);
   
  int tempo = 60000 / BPM;
  delay(tempo / 3);

}